<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 8. Advanced Development</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="GateIn Reference Guide"/><link rel="up" href="index.html" title="GateIn Reference Guide"/><link rel="prev" href="wsrp.html" title="Chapter 7. Web Services for Remote Portlets (WSRP)"/></head><body><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="wsrp.html"><strong>Prev</strong></a></li><li class="next"/></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="chap-Reference_Guide-Advanced"/>Chapter 8. Advanced Development</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="chap-Reference_Guide-Advanced.html#sect-Reference_Guide-Foundations">8.1. Foundations</a></span></dt><dd><dl><dt><span class="section"><a href="chap-Reference_Guide-Advanced.html#sect-Reference_Guide-Foundations-Kernel">8.1.1. GateIn Kernel</a></span></dt><dt><span class="section"><a href="chap-Reference_Guide-Advanced.html#sect-Reference_Guide-Foundations-Configuring_services">8.1.2. Configuring services</a></span></dt><dt><span class="section"><a href="chap-Reference_Guide-Advanced.html#sect-Reference_Guide-Foundations-Configuration_syntax">8.1.3. Configuration syntax</a></span></dt><dt><span class="section"><a href="chap-Reference_Guide-Advanced.html#sect-Reference_Guide-Foundations-Init_params">8.1.4. InitParams configuration object</a></span></dt><dt><span class="section"><a href="chap-Reference_Guide-Advanced.html#sect-Reference_Guide-Foundations-Configuring_portal">8.1.5. Configuring a portal container</a></span></dt><dt><span class="section"><a href="chap-Reference_Guide-Advanced.html#sect-Reference_Guide-Foundations-Extension_mechanism">8.1.6. GateIn Extension Mechanism, and Portal Extensions</a></span></dt><dt><span class="section"><a href="chap-Reference_Guide-Advanced.html#sect-Reference_Guide-Foundations-Multiple_portals">8.1.7. Running Multiple Portals</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sect-Reference_Guide-Foundations"/>8.1. Foundations</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Reference_Guide-Foundations-Kernel"/>8.1.1. GateIn Kernel</h3></div></div></div><p>
         GateIn 3.1 is built as a set of services on top of the dependency injection kernel. The kernel provides configuration, lifecycle handling, component scopes, and some core services.
      </p><p>
         Service components exist in two scopes. The first scope is represented by <span class="bold"><strong>RootContainer</strong></span> - it contains services that exist independently of any portal, and can be
         accessed by all portals.
      </p><p>
         The second scope is portal-private in the form of <span class="bold"><strong>PortalContainer</strong></span>. Each portal lives in an instance of PortalContainer.
         This scope contains services that are common for a set of portals, and services which should not be shared by all portals.
      </p><p>
         </p><div class="mediaobject" align="center"><img src="images/Advanced/Foundations/PortalContainers.png" align="middle"/></div><p>
      </p><p>
         Whenever a specific service is looked up through PortalContainer, and the service is not available, the lookup is
         delegated further up to RootContainer. We can therefore have the default instance of a certain component in
         RootContainer, and portal specific instances in some or all PortalContainers which override the default
         instance.
      </p><p>
         Whenever your portal application has to be integrated more closely with GateIn services, the way to do it is by
         looking up these services through PortalContainer. Be careful though - only officially documented services
         should be accessed this way, and used according to documentation, as most of the services are an implementation
         detail of GateIn, and subject to change without notice.
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Reference_Guide-Foundations-Configuring_services"/>8.1.2. Configuring services</h3></div></div></div><p>GateIn Kernel uses the dependency injection to create services based on the <span class="bold"><strong>configuration.xml</strong></span> configuration files.
         The location of the configuration files determines if services are placed into the RootContainer scope, or into the PortalContainer scope.
         All configuration.xml files located at <span class="bold"><strong>conf/configuration.xml</strong></span> in the classpath (any directory, or any jar in the classpath) will have their
      services configured at the RootContainer scope.
      All configuration.xml files located at <span class="bold"><strong>conf/portal/configuration.xml</strong></span> in the classpath will have their services configured at the PortalContainer scope.
      Additionally, <span class="bold"><strong>portal extensions</strong></span> can contain configuration in <span class="bold"><strong>WEB-INF/conf/configuration.xml</strong></span>, and will also have their services configured at the PortalContainer scope.
      </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Portal extensions are described later.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Reference_Guide-Foundations-Configuration_syntax"/>8.1.3. Configuration syntax</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Reference_Guide-Foundations-Configuration_syntax-Component"/>8.1.3.1. Components</h4></div></div></div><p>A service component is defined in the <span class="bold"><strong>configuration.xml file</strong></span> by using <span class="bold"><strong>&lt;component&gt;</strong></span> element.</p><p>There is only one required information when defining a service - the service implementation class, specified using <span class="bold"><strong>&lt;type&gt;</strong></span></p><p>Every component has a <span class="bold"><strong>&lt;key&gt;</strong></span> that identifies it. If not explicitly set, a key defaults to the value of &lt;type&gt;.
         If the key is loaded as a class, the Class or String object will be used as a key.</p><p>The usual approach is to specify an interface as a key.</p><div class="example"><a id="d0e5417"/><p class="title"><b>Example 8.1. Example of service component configuration:</b></p><div class="example-contents"><pre class="programlisting">
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;configuration
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.exoplaform.org/xml/ns/kernel_1_0.xsd
                          http://www.exoplaform.org/xml/ns/kernel_1_0.xsd"
      xmlns="http://www.exoplaform.org/xml/ns/kernel_1_0.xsd"&gt;
   &lt;component&gt;
      &lt;key&gt;org.exoplatform.services.database.HibernateService&lt;/key&gt;
      &lt;type&gt;org.exoplatform.services.database.impl.HibernateServiceImpl&lt;/type&gt;

      ...

   &lt;/component&gt;
&lt;/configuration&gt;
      </pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Reference_Guide-Foundations-Configuration_syntax-External_plugins"/>8.1.3.2. External Plugins</h4></div></div></div><p>GateIn Kernel supports non-component objects that can be configured, instantiated, and injected into registered components, using method calls.
         The mechanism is called 'plugins', and allows portal extensions to add additional configurations to core services.</p><p>The external plugin is defined by using the <span class="bold"><strong>&lt;external-component-plugins&gt;</strong></span> wrapper element which contains one or more
            <span class="bold"><strong>&lt;component-plugin&gt;</strong></span> definitions. &lt;external-component-plugins&gt; uses <span class="bold"><strong>&lt;target-component&gt;</strong></span> to specify a target service component that will receive injected objects.</p><p>Every &lt;component-plugin&gt; defines an implementation type, and a method on the target component
            to use for the injection (<span class="bold"><strong>&lt;set-method&gt;</strong></span>). </p><p>A plugin implementation class has to implement the <span class="bold"><strong>org.exoplatform.container.component. ComponentPlugin</strong></span> interface.</p><p>In the following example, <span class="bold"><strong>PortalContainerDefinitionPlugin</strong></span> implements ComponentPlugin:</p><div class="example"><a id="d0e5453"/><p class="title"><b>Example 8.2. PortalContainerDefinitionPlugin</b></p><div class="example-contents"><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.exoplaform.org/xml/ns/kernel_1_0.xsd
                          http://www.exoplaform.org/xml/ns/kernel_1_0.xsd"
      xmlns="http://www.exoplaform.org/xml/ns/kernel_1_0.xsd"&gt;

   &lt;external-component-plugins&gt;
      &lt;target-component&gt;org.exoplatform.container.definition.PortalContainerConfig&lt;/target-component&gt;
      &lt;component-plugin&gt;
         &lt;!-- The name of the plugin --&gt;
         &lt;name&gt;Add PortalContainer Definitions&lt;/name&gt;

         &lt;!-- The name of the method to call on the PortalContainerConfig
              in order to register the PortalContainerDefinitions --&gt;
         &lt;set-method&gt;registerPlugin&lt;/set-method&gt;

         &lt;!-- The fully qualified name of the PortalContainerDefinitionPlugin --&gt;
         &lt;type&gt;org.exoplatform.container.definition.PortalContainerDefinitionPlugin&lt;/type&gt;

         ...

      &lt;/component-plugin&gt;
   &lt;/external-component-plugins&gt;
&lt;/configuration&gt;
         </pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Reference_Guide-Foundations-Configuration_syntax-Includes"/>8.1.3.3. Includes, and special URLs</h4></div></div></div><p>It is possible to break the <span class="bold"><strong>configuration.xml</strong></span> file into many smaller files, that are then included into a 'master' configuration file.
         The included files are complete configuration.xml documents, not fragments of text.</p><p>The following is an example configuration.xml which 'outsources' its content into several files:</p><pre class="programlisting">
&lt;configuration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.exoplaform.org/xml/ns/kernel_1_0.xsd
                          http://www.exoplaform.org/xml/ns/kernel_1_0.xsd"
      xmlns="http://www.exoplaform.org/xml/ns/kernel_1_0.xsd"&gt;

   &lt;import&gt;war:/conf/sample-ext/jcr/jcr-configuration.xml&lt;/import&gt;
   &lt;import&gt;war:/conf/sample-ext/portal/portal-configuration.xml&lt;/import&gt;

&lt;/configuration&gt;
         </pre><p>The special URL is used to refer to another configuration file.
            The URL schema <span class="bold"><strong>'war:'</strong></span> means that the path following is resolved that is related to the current PortalContainer's servlet context resource path, starting at <span class="bold"><strong>WEB-INF</strong></span> as the root.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The current PortalContainer is really a newly created PortalContainer, as war: URLs only make sense for PortalContainer scoped configuration.</p></div><p>Also, thanks to the extension mechanism, the servlet context used for resource loading is a <span class="bold"><strong>unified servlet context</strong></span> (as explaned in a later section).</p><p>To include the resolved path related to the current classpath (context classloader), use the <span class="bold"><strong>'jar:'</strong></span> URL schema.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Reference_Guide-Foundations-Configuration_syntax-Special_vars"/>8.1.3.4. Special variables</h4></div></div></div><p>The configuration files may contain a <span class="bold"><strong>special variable</strong></span> reference <span class="emphasis"><em>${container.name.suffix}</em></span>. This variable resolves to the name of the current portal container, prefixed by underscore (_).
         This facilitates reuse of configuration files in cases where portal specific unique names need to be assigned to some resources
         (For example, JNDI names, Database / DataSource names, JCR repository names).</p><p>This variable is only defined when there is a current PortalContainer available - only for PortalContainer scoped services.</p><p>A good example for this is <span class="bold"><strong>HibernateService</strong></span>:</p><div class="example"><a id="sect-Reference_Guide-Foundations-Configuration_syntax-Special_vars-Example"/><p class="title"><b>Example 8.3. HibernateService using variables</b></p><div class="example-contents"><pre class="programlisting">
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;configuration
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.exoplaform.org/xml/ns/kernel_1_0.xsd
                       http://www.exoplaform.org/xml/ns/kernel_1_0.xsd"
   xmlns="http://www.exoplaform.org/xml/ns/kernel_1_0.xsd"&gt;

   &lt;component&gt;
      &lt;key&gt;org.exoplatform.services.database.HibernateService&lt;/key&gt;
      &lt;jmx-name&gt;database:type=HibernateService&lt;/jmx-name&gt;
      &lt;type&gt;org.exoplatform.services.database.impl.HibernateServiceImpl&lt;/type&gt;
      &lt;init-params&gt;
         &lt;properties-param&gt;
            &lt;name&gt;hibernate.properties&lt;/name&gt;
            &lt;description&gt;Default Hibernate Service&lt;/description&gt;
            &lt;property name="hibernate.show_sql" value="false" /&gt;
            &lt;property name="hibernate.cglib.use_reflection_optimizer" value="true" /&gt;
            &lt;property name="hibernate.connection.url"
                            value="jdbc:hsqldb:file:../temp/data/exodb${container.name.suffix}" /&gt;
            &lt;property name="hibernate.connection.driver_class" value="org.hsqldb.jdbcDriver" /&gt;
            &lt;property name="hibernate.connection.autocommit" value="true" /&gt;
            &lt;property name="hibernate.connection.username" value="sa" /&gt;
            &lt;property name="hibernate.connection.password" value="" /&gt;
            &lt;property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect" /&gt;
            &lt;property name="hibernate.c3p0.min_size" value="5" /&gt;
            &lt;property name="hibernate.c3p0.max_size" value="20" /&gt;
            &lt;property name="hibernate.c3p0.timeout" value="1800" /&gt;
            &lt;property name="hibernate.c3p0.max_statements" value="50" /&gt;
         &lt;/properties-param&gt;
      &lt;/init-params&gt;
   &lt;/component&gt;
&lt;/configuration&gt;
         </pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Reference_Guide-Foundations-Init_params"/>8.1.4. InitParams configuration object</h3></div></div></div><p>
         <code class="literal">InitParams</code> are the configuration object that is essentially a map of key-value pairs,
         where key is always a <code class="literal">String</code>, and value can be any type that can be described
         using the kernel configuration.xml.
      </p><p>
         Service components that form GateIn 3.1 insfrastructure use the <code class="literal">InitParams</code> object to configure themselves.
         A component can have one instance of InitParams injected at most. If the service component's constructor takes InitParams
         as any of the parameters, it will automatically be injected at the component instantiation time. The xml configuration
         for a service component that expects the InitParams object must include the &lt;init-params&gt; element (even if the empty one).
      </p><p>
         To learn about how the kernel xml configuration syntax looks for creating <code class="literal">InitParams</code> instances, see the following example.
      </p><div class="example"><a id="d0e5535"/><p class="title"><b>Example 8.4. InitParams - properties-param</b></p><div class="example-contents"><pre class="programlisting">
&lt;component&gt;
   &lt;key&gt;org.exoplatform.services.naming.InitialContextInitializer&lt;/key&gt;
   &lt;type&gt;org.exoplatform.services.naming.InitialContextInitializer&lt;/type&gt;
   &lt;init-params&gt;
      &lt;properties-param&gt;
         &lt;name&gt;default-properties&lt;/name&gt;
         &lt;description&gt;Default initial context properties&lt;/description&gt;
         &lt;property name="java.naming.factory.initial"
                  value="org.exoplatform.services.naming.SimpleContextFactory" /&gt;
      &lt;/properties-param&gt;
   &lt;/init-params&gt;
&lt;/component&gt;
         </pre></div></div><br class="example-break"/><p>
         The InitParams object description begins with the &lt;init-params&gt; element. It can have zero or more children elements,
         each of which is one of &lt;value-param&gt;, &lt;values-param&gt;, &lt;properties-param&gt;, or &lt;object-param&gt;.
         Each of these child elements takes a &lt;name&gt; that serves as a map entry key, and an optional &lt;description&gt;.
         It also takes a type-specific value specification.
      </p><p>
         For &lt;properties-param&gt;, the value specification is in the form of one or more &lt;property&gt; elements,
         each of which specifies two strings - a property name, and a property value. Each &lt;properties-params&gt;
         defines one <code class="literal">java.util.Properties</code> instance. Also, see
         <a href="chap-Reference_Guide-Advanced.html#sect-Reference_Guide-Foundations-Configuration_syntax-Special_vars-Example" title="Example 8.3. HibernateService using variables">Example 8.3, “HibernateService using variables”</a> for an example.
      </p><div class="example"><a id="d0e5549"/><p class="title"><b>Example 8.5. InitParams - value-param</b></p><div class="example-contents"><pre class="programlisting">
&lt;component&gt;
   &lt;key&gt;org.exoplatform.services.transaction.TransactionService&lt;/key&gt;
   &lt;type&gt;org.exoplatform.services.transaction.impl.jotm.TransactionServiceJotmImpl&lt;/type&gt;
   &lt;init-params&gt;
      &lt;value-param&gt;
         &lt;name&gt;timeout&lt;/name&gt;
         &lt;value&gt;5&lt;/value&gt;
      &lt;/value-param&gt;
   &lt;/init-params&gt;
&lt;/component&gt;
         </pre></div></div><br class="example-break"/><p>
         For &lt;value-param&gt;, the value specification is in the form of &lt;value&gt; element, which defines
         one <code class="literal">String</code> instance.         
      </p><div class="example"><a id="d0e5559"/><p class="title"><b>Example 8.6. InitParams - values-param</b></p><div class="example-contents"><pre class="programlisting">
&lt;component&gt;
  &lt;key&gt;org.exoplatform.services.resources.ResourceBundleService&lt;/key&gt;
  &lt;type&gt;org.exoplatform.services.resources.impl.SimpleResourceBundleService&lt;/type&gt;
    &lt;init-params&gt;
      &lt;values-param&gt;
        &lt;name&gt;classpath.resources&lt;/name&gt;
        &lt;description&gt;The resources  that start with the following package name should be load from file system&lt;/description&gt;
        &lt;value&gt;locale.portlet&lt;/value&gt;
      &lt;/values-param&gt;

      &lt;values-param&gt;
        &lt;name&gt;init.resources&lt;/name&gt;
        &lt;description&gt;Store the following resources into the db for  the first launch &lt;/description&gt;
        &lt;value&gt;locale.test.resources.test&lt;/value&gt;
      &lt;/values-param&gt;

      &lt;values-param&gt;
        &lt;name&gt;portal.resource.names&lt;/name&gt;
        &lt;description&gt;The properties files of  the portal ,  those file will be merged
          into one ResourceBundle properties &lt;/description&gt;
        &lt;value&gt;local.portal.portal&lt;/value&gt;
        &lt;value&gt;local.portal.custom&lt;/value&gt;
      &lt;/values-param&gt;
    &lt;/init-params&gt;
&lt;/component&gt;
         </pre></div></div><br class="example-break"/><p>
      For &lt;values-param&gt;, the value specification is in the form of one or more &lt;value&gt; elements,
         each of which represents one <code class="literal">String</code> instance, where all the <code class="literal">String</code> values
         are then collected into a <code class="literal">java.util.List</code> instance.
      </p><div class="example"><a id="d0e5575"/><p class="title"><b>Example 8.7. InitParams - object-param</b></p><div class="example-contents"><pre class="programlisting">
&lt;component&gt;
   &lt;key&gt;org.exoplatform.services.cache.CacheService&lt;/key&gt;
   &lt;jmx-name&gt;cache:type=CacheService&lt;/jmx-name&gt;
   &lt;type&gt;org.exoplatform.services.cache.impl.CacheServiceImpl&lt;/type&gt;
   &lt;init-params&gt;
      &lt;object-param&gt;
         &lt;name&gt;cache.config.default&lt;/name&gt;
         &lt;description&gt;The default cache configuration&lt;/description&gt;
         &lt;object type="org.exoplatform.services.cache.ExoCacheConfig"&gt;
            &lt;field name="name"&gt;
               &lt;string&gt;default&lt;/string&gt;
            &lt;/field&gt;
            &lt;field name="maxSize"&gt;
               &lt;int&gt;300&lt;/int&gt;
            &lt;/field&gt;
            &lt;field name="liveTime"&gt;
               &lt;long&gt;300&lt;/long&gt;
            &lt;/field&gt;
            &lt;field name="distributed"&gt;
               &lt;boolean&gt;false&lt;/boolean&gt;
            &lt;/field&gt;
            &lt;field name="implementation"&gt;
               &lt;string&gt;org.exoplatform.services.cache.concurrent.ConcurrentFIFOExoCache&lt;/string&gt;
            &lt;/field&gt;
         &lt;/object&gt;
      &lt;/object-param&gt;
   &lt;/init-params&gt;
&lt;/component&gt;
         </pre></div></div><br class="example-break"/><p>
         For &lt;object-param&gt;, the value specification comes in a form of the &lt;object&gt; element, which is
         used for the POJO style object specification (you specify an implementation class - &lt;type&gt;, and property values - &lt;field&gt;).
      </p><p>
         Also see <a href="chap-Reference_Guide-Advanced.html#sect-Reference_Guide-Foundations-Configuring_portal_Container_declaration_example" title="Example 8.8. Portal container declaration example">Example 8.8, “Portal container declaration example”</a>
         for an example of specifying a field of the <code class="literal">Collection</code> type. 
      </p><p>
      The <code class="literal">InitParams</code> structure - the names and types of entries is specific for each service,
         as it is the code inside service components's class that decides what entry names to look up and what types
         it expects to find.
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Reference_Guide-Foundations-Configuring_portal"/>8.1.5. Configuring a portal container</h3></div></div></div><p>
         A <span class="bold"><strong>portal container</strong></span> is defined by several attributes.
      </p><p>
         First, there is a <span class="bold"><strong>portal container name</strong></span>, which is always equal to the URL context to which the current portal is bound.
      </p><p>
         Second, there is a <span class="bold"><strong>REST context name</strong></span>, which is used for REST access to portal application - every portal has
         exactly one (unique) REST context name.
      </p><p>
         Then, there is a <span class="bold"><strong>realm name</strong></span> which is the name of security realm used for authentication when users log into the
         portal.
      </p><p>
         Finally, there is a list of <span class="bold"><strong>Dependencies</strong></span> - other web applications, whose resources are visible to current
         portal (via extension mechanism described later), and are searched in the specified order.
      </p><div class="example"><a id="sect-Reference_Guide-Foundations-Configuring_portal_Container_declaration_example"/><p class="title"><b>Example 8.8. Portal container declaration example</b></p><div class="example-contents"><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.exoplaform.org/xml/ns/kernel_1_0.xsd
                       http://www.exoplaform.org/xml/ns/kernel_1_0.xsd"
   xmlns="http://www.exoplaform.org/xml/ns/kernel_1_0.xsd"&gt;

   &lt;external-component-plugins&gt;
      &lt;!-- The full qualified name of the PortalContainerConfig --&gt;
      &lt;target-component&gt;org.exoplatform.container.definition.PortalContainerConfig&lt;/target-component&gt;

      &lt;component-plugin&gt;
         &lt;!-- The name of the plugin --&gt;
         &lt;name&gt;Add PortalContainer Definitions&lt;/name&gt;

         &lt;!-- The name of the method to call on the PortalContainerConfig
              in order to register the PortalContainerDefinitions --&gt;
         &lt;set-method&gt;registerPlugin&lt;/set-method&gt;

         &lt;!-- The full qualified name of the PortalContainerDefinitionPlugin --&gt;
         &lt;type&gt;org.exoplatform.container.definition.PortalContainerDefinitionPlugin&lt;/type&gt;

         &lt;init-params&gt;
            &lt;object-param&gt;
               &lt;name&gt;portal&lt;/name&gt;
               &lt;object type="org.exoplatform.container.definition.PortalContainerDefinition"&gt;
                  &lt;!-- The name of the portal container --&gt;
                  &lt;field name="name"&gt;&lt;string&gt;portal&lt;/string&gt;&lt;/field&gt;

                  &lt;!-- The name of the context name of the rest web application --&gt;
                  &lt;field name="restContextName"&gt;&lt;string&gt;rest&lt;/string&gt;&lt;/field&gt;

                  &lt;!-- The name of the realm --&gt;
                  &lt;field name="realmName"&gt;&lt;string&gt;exo-domain&lt;/string&gt;&lt;/field&gt;

                  &lt;!-- All the dependencies of the portal container ordered by loading priority --&gt;
                  &lt;field name="dependencies"&gt;
                     &lt;collection type="java.util.ArrayList"&gt;
                        &lt;value&gt;
                           &lt;string&gt;eXoResources&lt;/string&gt;
                        &lt;/value&gt;
                        &lt;value&gt;
                           &lt;string&gt;portal&lt;/string&gt;
                        &lt;/value&gt;
                        &lt;value&gt;
                           &lt;string&gt;dashboard&lt;/string&gt;
                        &lt;/value&gt;
                        &lt;value&gt;
                           &lt;string&gt;exoadmin&lt;/string&gt;
                        &lt;/value&gt;
                        &lt;value&gt;
                           &lt;string&gt;eXoGadgets&lt;/string&gt;
                        &lt;/value&gt;
                        &lt;value&gt;
                           &lt;string&gt;eXoGadgetServer&lt;/string&gt;
                        &lt;/value&gt;
                        &lt;value&gt;
                           &lt;string&gt;rest&lt;/string&gt;
                        &lt;/value&gt;
                        &lt;value&gt;
                           &lt;string&gt;web&lt;/string&gt;
                        &lt;/value&gt;
                        &lt;value&gt;
                           &lt;string&gt;wsrp-producer&lt;/string&gt;
                        &lt;/value&gt;
                        &lt;!-- The sample-ext has been added at the end of the dependency list
                             in order to have the highest priority --&gt;
                        &lt;value&gt;
                           &lt;string&gt;sample-ext&lt;/string&gt;
                        &lt;/value&gt;
                     &lt;/collection&gt;
                  &lt;/field&gt;
               &lt;/object&gt;
            &lt;/object-param&gt;
         &lt;/init-params&gt;
      &lt;/component-plugin&gt;
   &lt;/external-component-plugins&gt;
&lt;/configuration&gt;
      
</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Dependencies are part of the extension mechanism.</p></div><p>
         Every <span class="bold"><strong>portal container</strong></span> is represented by a <span class="bold"><strong>PortalContainer instance</strong></span>, including:
         </p><div class="itemizedlist"><ul><li><p>Associated <span class="bold"><strong>ExoContainerContext</strong></span> containing information about the portal.</p></li><li><p><span class="bold"><strong>Unified servlet context</strong></span> for web-archive-relative resource loading.</p></li><li><p><span class="bold"><strong>Unified classloader</strong></span> for classpath based resource loading.</p></li><li><p>Methods for retrieving services.</p></li></ul></div><p>
      </p><p>
         <span class="bold"><strong>Unified servlet context</strong></span>, and <span class="bold"><strong>unified classloader</strong></span> are part of the <span class="bold"><strong>extension mechanism</strong></span> (explained in next section),
         and provide standard APIs (ServletContext, ClassLoader) with the specific resource loading behavior - visibility into the associated web application archives, configured with Dependencies property of PortalContainerDefinition. Resources from other web applications are queried in the order specified by Dependencies.
         The later entries in the list override the previous ones.
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Reference_Guide-Foundations-Extension_mechanism"/>8.1.6. GateIn Extension Mechanism, and Portal Extensions</h3></div></div></div><p>
         <span class="bold"><strong>Extension mechanism</strong></span> is a functionality that makes it possible to override the portal resources in an almost
         plug-and-play fashion - just drop in a .war archive with the resources, and configure its position on the portal's
         classpath.
         This way any customizations of the portal do not have to involve unpacking and repacking the original portal
         .war archives. Instead, create your own .war archive with changed resources that override the resources in
         the original archive.
      </p><p>
         A web archive packaged in a way to be used through the extension mechanism is called <span class="bold"><strong>portal extension</strong></span>.
      </p><p>
         There are two steps necessary to create a portal extension.
      </p><p>
         First, declare <span class="bold"><strong>PortalConfigOwner</strong></span> servlet context listener in web.xml of your web application.
      </p><div class="example"><a id="d0e5690"/><p class="title"><b>Example 8.9. Example of a portal extension called sample-ext:</b></p><div class="example-contents"><pre class="programlisting">
&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;
&lt;!DOCTYPE web-app PUBLIC -//Sun Microsystems, Inc.//DTD Web Application 2.3//EN
     http://java.sun.com/dtd/web-app_2_3.dtd&gt;
&lt;web-app&gt;

   &lt;display-name&gt;sample-ext&lt;/display-name&gt;

   &lt;listener&gt;
      &lt;listener-class&gt;org.exoplatform.container.web.PortalContainerConfigOwner&lt;/listener-class&gt;
   &lt;/listener&gt;

   ...

&lt;/web-app&gt;
      </pre></div></div><br class="example-break"/><p>
         Then, add the servlet context name of this web application to a proper location in the list of Dependencies of the PortalContainerDefinition
         of all the portal containers that you want to access its resources.
      </p><p>
         After this step, your web archive will be on the portal's unified classpath, and unified servlet context resource path.
         The later in the Dependencies list your application is, the higher priority it has when resources are loaded by portal.
      </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>See the 'Configuring a portal' section for example of PortalContainerDefinition, that has sample-ext at the end of its list of Dependencies.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Reference_Guide-Foundations-Multiple_portals"/>8.1.7. Running Multiple Portals</h3></div></div></div><p>
         It is possible to run several independent portal containers - each bound to a different URL context - within
         the same JVM instance. This kind of setup is very efficient from administration and resource consumption. The most elegant way to <span class="bold"><strong>reuse</strong></span> configuration for different coexisting portals is by way of extension
         mechanism - by <span class="bold"><strong>inheriting</strong></span> resources and configuration from existing web archives, and just <span class="bold"><strong>adding</strong></span> extra resources to it,
         and <span class="bold"><strong>overriding</strong></span> those that need to be changed by including modified copies.
      </p><p>
         In order for a portal application to correctly function when deployed in multiple portals, the application may
         have to dynamically query the information about the current portal container. The application should not make
         any assumptions about the name, and other information of the current portal, as there are now multiple different portals in play.
      </p><p>
         At any point during request processing, or lifecycle event processing, your application can retrieve this
         information through <span class="bold"><strong>org.exoplatform.container. ExoContainerContext</strong></span>.
         Sometimes your application needs to make sure that the proper <span class="bold"><strong>PortalContainer</strong></span>
         - the source of <span class="bold"><strong>ExoContainerContext</strong></span> - is associated with the current call.
      </p><p>
         If you ship servlets or servlet filters as part of your portal application, and if you need to access the portal
         specific resources at any time during the processing of the servlet or filter request, you need to make
         sure the servlet/filter is associated with the current container.
      </p><p>
         The proper way to do that is to make your servlet extend <span class="bold"><strong>org.exoplatform.container.web. AbstractHttpServlet</strong></span>
         class.
         This will not only properly initialize the current <span class="bold"><strong>PortalContainer</strong></span> for you, but will also set the current thread's
         context classloader to one that looks for resources in the associated web applications in the order specified by
         <span class="bold"><strong>Dependencies</strong></span> configuration (as explained in Extension mechanism section).
      </p><p>
         Similarly for filters, make sure your filter class extends <span class="bold"><strong>org.exoplatform.container.web. AbstractFilter</strong></span>.
         Both <span class="bold"><strong>AbstractHttpServlet</strong></span>, and <span class="bold"><strong>AbstractFilter</strong></span> have the same method <span class="bold"><strong>getContainer()</strong></span>,
         which returns the current <span class="bold"><strong>PortalContainer</strong></span>.

         If your servlet handles the requests by implementing the <span class="bold"><strong>service()</strong></span> method, you need to rename that method to match
         the following signature:</p><pre class="programlisting">
/**
 * Use this method instead of Servlet.service()
 */
protected void onService(ExoContainer container, HttpServletRequest req,
      HttpServletResponse res) throws ServletException, IOException;
         </pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
         The reason is that AbstractHttpServlet implements service() to perform its interception, and you don't want to
         overwrite (by overriding) this functionality.
         </p></div><p>
         You may also need to access portal information within your <span class="bold"><strong>HttpSessionListener</strong></span>. Again, make sure to extend the
         provided abstract class - <span class="bold"><strong>org.exoplatform.container.web. AbstractHttpSessionListener</strong></span>.
         Also, modify your method signatures as follows:</p><pre class="programlisting">
/**
 * Use this method instead of HttpSessionListener.sessionCreated()
 */
protected void onSessionCreated(ExoContainer container, HttpSessionEvent event);

/**
 * Use this method instead of HttpSessionListener.sessionDestroyed()
 */
protected void onSessionDestroyed(ExoContainer container, HttpSessionEvent event);
         </pre><p>
         There is another method you have to implement in this case:</p><pre class="programlisting">
/**
 * Method should return true if unified servlet context,
 * and unified classloader should be made available
 */
protected boolean requirePortalEnvironment();
         </pre><p>
         If this method returns true, the current thread's context classloader is set up according to the <span class="bold"><strong>Dependencies</strong></span>
         configuration, and availability of the associated web applications. If it returns false, the standard
         application separation rules are used for resource loading (effectively turning off the
         extension mechanism). This method exists on <span class="bold"><strong>AbstractHttpServlet</strong></span> and <span class="bold"><strong>AbstractFilter</strong></span> as well, where there is a
         default implementation that automatically returns true, when it detects there is a current PortalContainer
         present. Otherwises, it returns false.

      </p><p>
         The followings explain how to properly perform the <span class="bold"><strong>ServletContextListener</strong></span> based initialization, when you need
         to access the current PortalContainer.
      </p><p>
         GateIn has no direct control over the deployment of application archives (.war, .ear files) - it is the
         application server performing the deployment. For the <span class="bold"><strong>extension mechanism</strong></span> to work properly, the applications,
         associated with the portal via the <span class="bold"><strong>Dependencies</strong></span> configuration, have to be deployed before the portal, that depends
         on them, is initialized. On the other hand, these applications may require an already initialized PortalContainer
         to properly initialize themselves - we have a recursive dependency problem. To resolve this problem, a
         mechanism of <span class="bold"><strong>initialization tasks</strong></span>, and <span class="bold"><strong>task queues</strong></span>, was put in place. Web applications that depend on the current
         PortalContainer for their initialization have to avoid performing their initialization directly in some
         ServletContextListener executed during their deployment (before any PortalContainer was initialized). Instead,
         a web application should package its initialization logic into an init task of the appropriate type, and only use
         ServletContextListener to insert the init task instance into the proper init tasks queue.
      </p><p>An example of this is the Gadgets application which registers the Google gadgets with the current PortalContainer:
      </p><pre class="programlisting">
public class GadgetRegister implements ServletContextListener
{
   public void contextInitialized(ServletContextEvent event)
   {
      // Create a new post-init task
      final PortalContainerPostInitTask task = new PortalContainerPostInitTask() {

         public void execute(ServletContext context, PortalContainer portalContainer)
         {
            try
            {
               SourceStorage sourceStorage =
               (SourceStorage) portalContainer.getComponentInstanceOfType(SourceStorage.class);
               ...
            }
            catch (RuntimeException e)
            {
               throw e;
            }
            catch (Exception e)
            {
               throw new RuntimeException("Initialization failed: ", e);
            }
         }
      };

      // Add post-init task for execution on all the portal containers
      // that depend on the given ServletContext according to 
      // PortalContainerDefinitions (via Dependencies configuration)
      PortalContainer.addInitTask(event.getServletContext(), task);
   }
}
      </pre><p>
         The above example uses <span class="bold"><strong>PortalContainerPostInitTask</strong></span>, which gets executed after the portal container has been
         initialized. In some cases, you may want to execute the initialization after portal container was instantiated,
         but before it was initialized - use <span class="bold"><strong>PortalContainerPreInitTask</strong></span> in that case. Or, you may want to execute
         initialization after all the post-init tasks have been executed - use <span class="bold"><strong>PortalContainerPostCreateTask</strong></span> in that case.
      </p><p>
         Also, you may need to pay attention to <span class="bold"><strong>LoginModules</strong></span>. If you use custom LoginModules which require
         the current ExoContainer, make sure they extend <span class="bold"><strong>org.exoplatform.services.security.jaas.AbstractLoginModule</strong></span> for
         the proper initialization. AbstractLoginModule also takes care of the basic configuration - it recognizes two
         initialization options - <span class="bold"><strong>portalContainerName</strong></span>, and <span class="bold"><strong>realmName</strong></span> whose values you can access via protected fields of
         the same name.
      </p></div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="wsrp.html"><strong>Prev</strong>Chapter 7. Web Services for Remote Portlets (WSRP)</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li></ul></body></html>